<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Masterworks\MasterworksRelease\.Net\Platform\Aurigo.Common.Utility\BrixExtensionHelper.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Web;
using System.Web.Script.Serialization;
using System.Xml;
using System.Xml.Serialization;

namespace Aurigo.Brix.Platform.CoreUtilities.Utility
{
    public static class BrixDatatypeHelper
    {
        #region Delegates

        public delegate string EvaluaterFunction(string simpleExpression);

        #endregion

        public static string ToUpper2(this string str)
        {
            return str.ToUpperInvariant();
        }

        public static string ToLower2(this string str)
        {
            return str.ToLowerInvariant();
        }

        public static string ToTitleCase2(this string str)
        {
            return System.Threading.Thread.CurrentThread.CurrentCulture.TextInfo.ToTitleCase(str.ToLower());
        }

        public static short ToInt16_2(this object str)
        {
            return Convert.ToInt16(str, CultureInfo.InvariantCulture);
        }

        public static int ToInt32_2(this object str)
        {
            return Convert.ToInt32(str, CultureInfo.InvariantCulture);
        }

        public static Int64 ToInt64_2(this object str)
        {
            return Convert.ToInt64(str, CultureInfo.InvariantCulture);
        }

        public static string Format2(this string str, params object[] objs)
        {
            return string.Format(CultureInfo.InvariantCulture, str, objs);
        }

        public static decimal ToDecimal2(this string str)
        {
            return Convert.ToDecimal(str, CultureInfo.InvariantCulture);
        }

        public static decimal ToDecimal2(this object str)
        {
            return Convert.ToDecimal(str, CultureInfo.InvariantCulture);
        }

        public static double ToDouble2(this string str)
        {
            return Convert.ToDouble(str, CultureInfo.InvariantCulture);
        }

        public static double ToDouble2(this int str)
        {
            return Convert.ToDouble(str, CultureInfo.InvariantCulture);
        }

        public static double ToDouble2(this object str)
        {
            return Convert.ToDouble(str, CultureInfo.InvariantCulture);
        }

        public static int Parse2(this string str)
        {
            return int.Parse(str, CultureInfo.InvariantCulture);
        }

        public static bool ToBoolean2(this string str, bool defaultValueIfNullOrEmpty)
        {
            try
            {
                if (string.IsNullOrEmpty(str))
                    return defaultValueIfNullOrEmpty;
                else
                    return str.ToBoolean2();
            }
            catch
            {
                return defaultValueIfNullOrEmpty;
            }
        }

        public static bool ToBoolean2(this string str)
        {
            if (!string.IsNullOrEmpty(str))
            {
                str = str.ToUpper2();
                if (str.IsEqualToAny(&quot;TRUE&quot;, &quot;YES&quot;))
                    return true;

                if (str.IsEqualToAny(&quot;FALSE&quot;, &quot;NO&quot;))
                    return false;
            }
            return Convert.ToBoolean(str, CultureInfo.InvariantCulture);
        }

        public static bool ToBoolean2(this object str)
        {
            return Convert.ToBoolean(str, CultureInfo.InvariantCulture);
        }

        public static bool ToBoolean2(this object str, bool defaultValueIfNullOrEmpty)
        {
            if (str == null || string.IsNullOrEmpty(str.ToString()))
                return defaultValueIfNullOrEmpty;

            return Convert.ToBoolean(str, CultureInfo.InvariantCulture);
        }

        public static string ToString2(this object str)
        {
            return Convert.ToString(str, CultureInfo.InvariantCulture);
        }

        public static string EscapeSpecial_XmlCharacters(this string str)
        {
            return str.Replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;).Replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;).Replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;);
        }

        //public static DateTime ToDateTime2(this object str)
        //{
        //    DateTime dt = default(DateTime);
        //    try
        //    {
        //        if (null == str || (str is String &amp;&amp; string.IsNullOrWhiteSpace((string)str))) return dt;
        //        dt = Convert.ToDateTime(str, CultureInfo.InvariantCulture);
        //    }
        //    catch
        //    {
        //        dt = Convert.ToDateTime(str);
        //    }
        //    return dt;
        //}

        public static string ToString2(this int intValue)
        {
            return intValue.ToString(CultureInfo.InvariantCulture);
        }

        public static string ToString2(this long intValue)
        {
            return intValue.ToString(CultureInfo.InvariantCulture);
        }

        public static string ToString2(this double intValue)
        {
            return intValue.ToString(CultureInfo.InvariantCulture);
        }

        public static string ToString2(this DateTime intValue)
        {
            return intValue.ToString(CultureInfo.InvariantCulture);
        }

        /// &lt;summary&gt;
        /// Get string between strings
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;str&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;from&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;to&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;include&quot;&gt;Include from and to in sub string&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static List&lt;string&gt; InBetween(this string str, string from, string to = &quot;&quot;, bool include = true)
        {
            List&lt;string&gt; strArr = new List&lt;string&gt;();
            if (!string.IsNullOrEmpty(from) &amp;&amp; str.Contains(from))
            {
                int indexOf = 0;

                while (indexOf != -1)
                {
                    indexOf = str.IndexOf(from, indexOf);
                    if (indexOf != -1)
                    {
                        if (!include) indexOf = indexOf + from.Length;

                        if (string.IsNullOrEmpty(to)) to = from;
                        int nextIndexOf = str.IndexOf(to, (indexOf + from.Length));
                        if (include) nextIndexOf = nextIndexOf + to.Length;

                        strArr.Add(str.Substring(indexOf, nextIndexOf - indexOf));

                        indexOf = (!include) ? (nextIndexOf + to.Length) : nextIndexOf;
                    }
                }
            }
            return strArr;
        }

        public static bool EndsWith2(this string intValue, string param)
        {
            return intValue.EndsWith(param, StringComparison.Ordinal);
        }

        public static bool StartsWith2(this string intValue, string param)
        {
            return intValue.StartsWith(param, StringComparison.Ordinal);
        }

        public static byte ToByte2(this object value)
        {
            return Convert.ToByte(value, CultureInfo.InvariantCulture);
        }

        public static string ParseExpression(this string expression, EvaluaterFunction evaluaterFunction,
            char left = &#39;[&#39;, char right = &#39;]&#39;)
        {
            var leftBraces = new Stack&lt;int&gt;();
            string workingExpression = expression;
            int currentCounter = 0;
            //check if the string has any of dynamic part to be evaluated
            if (workingExpression.IndexOfAny(new[] { left, right }) == -1)
                return expression;

            while (workingExpression.IndexOfAny(new[] { left, right }) != -1)
            {
                // left presents and comes before right --&gt; so push it into the stack
                if (workingExpression.IndexOf(left, currentCounter) != -1 &amp;&amp;
                    workingExpression.IndexOf(left, currentCounter) &lt; workingExpression.IndexOf(right, currentCounter))
                {
                    leftBraces.Push(workingExpression.IndexOf(left, currentCounter));
                    currentCounter = workingExpression.IndexOf(left, currentCounter) + 1;
                }
                else if (workingExpression.IndexOf(right, currentCounter) != -1)
                {
                    int lp = leftBraces.Pop();
                    string dynamicPart = workingExpression.Substring(lp + 1, workingExpression.IndexOf(right) - lp - 1);
                    workingExpression = workingExpression.Replace(left + dynamicPart + right,
                        evaluaterFunction(dynamicPart));
                    currentCounter = lp;
                }
                else
                {
                    // check for validations
                    if (leftBraces.Count() &gt; 0)
                        throw new Exception(&quot;Invalid Expression&quot;);
                    else
                        break;
                }
            }
            return workingExpression;
        }

        public static Dictionary&lt;string, string&gt; DeserializeToDictionary(this string colSetting, char itemDelimeter,
            char keyValueDelimeter)
        {
            return colSetting.Trim(itemDelimeter)
                .Split(itemDelimeter)
                .ToDictionary(x =&gt; x.Split(keyValueDelimeter)[0], y =&gt; y.Split(keyValueDelimeter)[1]);
        }

        public static string SerializeDTO(this object dto)
        {
            var memStrm = new MemoryStream();
            var xmlSink = new XmlTextWriter(memStrm, Encoding.Unicode);
            var xmlSer = new XmlSerializer(dto.GetType());
            xmlSer.Serialize(xmlSink, dto);
            memStrm.Position = 0;
            var sRead = new StreamReader(memStrm);
            return sRead.ReadToEnd();
        }

        public static bool IsNumeric(this DataColumn col)
        {
            if (col == null)
                return false;
            // Make this const
            var numericTypes = new[]
            {
                typeof (Byte), typeof (Decimal), typeof (Double),
                typeof (Int16), typeof (Int32), typeof (Int64), typeof (SByte),
                typeof (Single), typeof (UInt16), typeof (UInt32), typeof (UInt64)
            };
            return numericTypes.Contains(col.DataType);
        }

        public static bool IsEqualToAny&lt;T&gt;(this T source, params T[] compareArray) where T : IComparable
        {
            if (compareArray == null || compareArray.Length == 0)
                return (source == null);
            else
            {
                if (source == null)
                    return compareArray.Any(t =&gt; t == null);
                else
                    foreach (T cmp in compareArray)
                    {
                        if (cmp != null &amp;&amp; source.Equals(cmp))
                            return true;
                    }
            }

            return false;
        }

        public static bool IsEqualToAny(this string source, StringComparison comparisonType, params string[] compareArray)
        {
            if (compareArray == null || compareArray.Length == 0)
                return (source == null);
            else
            {
                if (source == null)
                    return compareArray.Any(t =&gt; t == null);
                else
                    foreach (string cmp in compareArray)
                    {
                        if (cmp != null &amp;&amp; source.Equals(cmp, comparisonType))
                            return true;
                    }
            }

            return false;
        }

        public static bool IsNullOrZero(this byte? source) { return (!source.HasValue || source.Value == 0); }

        public static bool IsNullOrZero(this int? source) { return (!source.HasValue || source.Value == 0); }

        public static bool IsNullOrZero(this long? source) { return (!source.HasValue || source.Value == 0); }

        public static bool IsNullOrZero(this float? source) { return (!source.HasValue || source.Value == 0); }

        public static bool IsNullOrZero(this double? source) { return (!source.HasValue || source.Value == 0); }

        public static bool IsNullOrZero(this decimal? source) { return (!source.HasValue || source.Value == 0); }

        public static bool IsNullOrCountIsZero&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source) { return (source == null || !source.Any()); }

        public static bool IsNotNullAndHasItems&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source) { return !IsNullOrCountIsZero(source); }


        /// &lt;summary&gt;
        /// Check to see if any of this strings are substring to the source string
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;source&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;compareArray&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static bool ContainsAny(this string source, params string[] compareArray)
        {
            if (compareArray == null || compareArray.Length == 0)
                return (source == null);
            else
            {
                if (source == null)
                    return compareArray.Any(t =&gt; t == null);
                else
                    foreach (string cmp in compareArray)
                    {
                        if (cmp != null &amp;&amp; source.Contains(cmp))
                            return true;
                    }
            }

            return false;
        }

        /// &lt;summary&gt;
        /// Checks if the list contains all of the specified parameters
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;Generic Type&lt;/typeparam&gt;
        /// &lt;param name=&quot;sourceList&quot;&gt;Generic list to compare&lt;/param&gt;
        /// &lt;param name=&quot;stringsToCompare&quot;&gt;Items to look for in the list&lt;/param&gt;
        /// &lt;returns&gt;True if the list contains all the items, false otherwise&lt;/returns&gt;
        public static bool ContainsAllOf&lt;T&gt;(this List&lt;T&gt; sourceList, params T[] stringsToCompare)
        {
            bool containsAllStrings = true;

            if (stringsToCompare == null || stringsToCompare.Length == 0)
                return containsAllStrings;

            foreach (T str in stringsToCompare)
            {
                if (!sourceList.Contains&lt;T&gt;(str))
                {
                    containsAllStrings = false;
                    break;
                }
            }

            return containsAllStrings;
        }

        /// &lt;summary&gt;
        /// Checks if the list contains any of the specified parameters
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;Generic Type&lt;/typeparam&gt;
        /// &lt;param name=&quot;sourceList&quot;&gt;Generic list to compare&lt;/param&gt;
        /// &lt;param name=&quot;stringsToCompare&quot;&gt;Items to look for in the list&lt;/param&gt;
        /// &lt;returns&gt;True if the list contains any the items, false otherwise&lt;/returns&gt;
        public static bool ContainsAnyOf&lt;T&gt;(this List&lt;T&gt; sourceList, params T[] stringsToCompare)
        {
            bool containsAllStrings = false;

            if (stringsToCompare == null || stringsToCompare.Length == 0)
                return true;

            foreach (T str in stringsToCompare)
            {
                if (sourceList.Contains&lt;T&gt;(str))
                {
                    containsAllStrings = true;
                    break;
                }
            }

            return containsAllStrings;
        }

        /// &lt;summary&gt;
        /// This methods truncates the text with ... if it exceeds maxLimit
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;maxLimit&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string TrimLongText(this string text, int maxLimit)
        {
            if (text.Length &lt;= maxLimit)
                return text;

            string retText = text.Substring(0, maxLimit - 3) + &quot;...&quot;;
            return retText;
        }

        public static string MakeValidFileName(this string fileName)
        {
            if (string.IsNullOrEmpty(fileName))
                return fileName;

            string invalidChars = System.Text.RegularExpressions.Regex.Escape(new string(System.IO.Path.GetInvalidFileNameChars()));
            string invalidRegStr = string.Format(@&quot;([{0}]*\.+$)|([{0}]+)&quot;, invalidChars);

            return System.Text.RegularExpressions.Regex.Replace(fileName, invalidRegStr, &quot;_&quot;);
        }

        /// &lt;summary&gt;
        /// This method is to be used only when we are sure that the param that is getting passed to the stored procedure is of type &quot;DATE&quot; (not DateTime).
        /// To method almost need not be used unless it is required by the stored proc as a DATE datatype.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;anyDateTime&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string ToDateOnlyString_ForDatabaseOpenXml(this DateTime anyDateTime)
        {
            return anyDateTime.Date.ToString(&quot;yyyy-MM-dd&quot;);// CultureInfo.CurrentCulture;
        }

        /// &lt;summary&gt;
        /// Use this method when sending datetime objects to database instead of ToString().
        /// Note: Database works in a different culture/language in comparision to the ASP.NET(or any other) web server.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;anyDateTime&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string ToDateTimeString_ForDatabaseOpenXml(this DateTime anyDateTime)
        {
            return anyDateTime.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;);// CultureInfo.CurrentCulture;
        }

        /// &lt;summary&gt;
        /// Converts the date time object to string in yyyy-MM-dd HH:mm:ss
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;anyDateTime&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string ToDateTimeString_InvariantCulture(this DateTime anyDateTime)
        {
            return anyDateTime.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;);// CultureInfo.CurrentCulture;
        }

        /// &lt;summary&gt;
        /// Converts the date time object to string in yyyy-MM-dd  
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;anyDateTime&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string ToDateString_InvariantCulture(this DateTime anyDateTime)
        {
            return anyDateTime.ToString(&quot;yyyy-MM-dd&quot;);// CultureInfo.CurrentCulture;
        }

        /// &lt;summary&gt;
        /// This method is to be used only when we are sure that the param that is getting passed to the stored procedure is of type &quot;DATE&quot; (not DateTime).
        /// To method almost need not be used unless it is required by the stored proc as a DATE datatype.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;anyDateTime&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string ToDateOnlyString_ForDatabaseOpenXml(this DateTime? anyDateTime)
        {
            if (anyDateTime == null)
                return string.Empty;

            return anyDateTime.Value.Date.ToDateOnlyString_ForDatabaseOpenXml();// CultureInfo.CurrentCulture;
        }

        /// &lt;summary&gt;
        /// Use this method when sending datetime objects to database instead of ToString().
        /// Note: Database works in a different culture/language in comparision to the ASP.NET(or any other) web server.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;anyDateTime&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string ToDateTimeString_ForDatabaseOpenXml(this DateTime? anyDateTime)
        {
            if (anyDateTime == null)
                return string.Empty;

            return anyDateTime.Value.ToDateTimeString_ForDatabaseOpenXml();// CultureInfo.CurrentCulture;
        }

        public static bool TryParseObjectAsDateTime(this object genericDateTimeObjectOrString, out DateTime dateTimeObject, CultureInfo cultureInfo)
        {
            if (genericDateTimeObjectOrString == null)
            {
                dateTimeObject = DateTime.MinValue;
                return false;
            }

            DateTime? out_dateTimeObject_Nullable;

            bool isSuccess = TryParseObjectAsDateTime(genericDateTimeObjectOrString, out out_dateTimeObject_Nullable, cultureInfo);

            if (isSuccess &amp;&amp; out_dateTimeObject_Nullable.HasValue)
            {
                dateTimeObject = out_dateTimeObject_Nullable.Value;
                return true;
            }

            dateTimeObject = DateTime.MinValue;
            return false;
        }

        public static bool TryParseObjectAsDateTime(this object genericDateTimeObjectOrString, out DateTime? dateTimeObject, CultureInfo cultureInfo)
        {
            dateTimeObject = null;

            if (genericDateTimeObjectOrString == null)
                return true;

            string strDateTime = genericDateTimeObjectOrString.ToString();

            if (string.IsNullOrEmpty(strDateTime))
                return true;

            if (genericDateTimeObjectOrString is DateTime?)
            {
                DateTime? nullableValue = (DateTime?)genericDateTimeObjectOrString;

                if (nullableValue.HasValue)
                    dateTimeObject = nullableValue;

                return true;
            }
            else if (genericDateTimeObjectOrString is DateTime)
            {
                dateTimeObject = (DateTime)genericDateTimeObjectOrString;
                return true;
            }

            DateTime temp_outDateTime; bool isSuccess = false;

            if (cultureInfo != null)
            {
                isSuccess = DateTime.TryParse(strDateTime, cultureInfo, DateTimeStyles.None, out temp_outDateTime);
                if (isSuccess)
                {
                    dateTimeObject = temp_outDateTime;
                    return isSuccess;
                }
                //else try the default thread culture parse
            }

            isSuccess = DateTime.TryParse(strDateTime, out temp_outDateTime);

            dateTimeObject = temp_outDateTime;

            return isSuccess;
        }

        public static bool TryParseObjectAsDateTimeString(this object genericDateTimeObjectOrString, out string dateTimeString, CultureInfo cultureInfo)
        {
            dateTimeString = null;
            DateTime outdateTimeObject;
            if (genericDateTimeObjectOrString.TryParseObjectAsDateTime(out outdateTimeObject, cultureInfo))
            {
                if (cultureInfo != null)
                    dateTimeString = outdateTimeObject.ToString(cultureInfo);
                else
                    dateTimeString = outdateTimeObject.ToString();
                return true;
            }

            return false;
        }

        public static bool TryParseObjectAsDateTimeStringNullable(this object genericDateTimeObjectOrString, out string dateTimeString, CultureInfo cultureInfo)
        {
            dateTimeString = null;
            DateTime? outdateTimeObject;
            if (genericDateTimeObjectOrString.TryParseObjectAsDateTime(out outdateTimeObject, cultureInfo))
            {
                if (!outdateTimeObject.HasValue)
                    dateTimeString = null;
                else
                {
                    if (cultureInfo != null)
                        dateTimeString = outdateTimeObject.Value.ToString(cultureInfo);
                    else
                        dateTimeString = outdateTimeObject.Value.ToString();
                }
                return true;
            }

            return false;
        }

        //public static string GetTryParseObjectAsDateTimeStringElseDefault(this object genericDateTimeObjectOrString, ref string defaultValue, CultureInfo cultureInfo)
        //{
        //    string outDateTimeText;
        //    if (genericDateTimeObjectOrString.TryParseObjectAsDateTimeString(out outDateTimeText, cultureInfo))
        //        return outDateTimeText;

        //    return defaultValue;
        //}

        public static DateTime TrimSecondsAndMilliSeconds(this DateTime dateTime)
        {
            return new DateTime(dateTime.Year, dateTime.Month, dateTime.Day, dateTime.Hour, dateTime.Minute, 0);
        }

        public static string GetInnerMostExceptionErrorMsg(this Exception ex)
        {
            if (ex.InnerException == null)
                return ex.Message;

            return GetInnerMostExceptionErrorMsg(ex.InnerException);
        }

        public static int GetIndex(this OrderedDictionary dictionary, string key)
        {
            int index = -1;
            foreach (string k in dictionary.Keys)
            {
                index++;
                if (k.Equals(key))
                    return index;
            }

            return -1;
        }
        public static string BrixHTMLEncode(this string text)
        {
            if (!string.IsNullOrWhiteSpace(text))
            {
                text = HttpUtility.HtmlEncode(text);
                text = text.Replace(&quot;:&quot;, &quot;&amp;colon;&quot;);
            }
            return text;
        }
        public static string BrixHTMLDecode(this string text)
        {
            if (!string.IsNullOrWhiteSpace(text))
            {
                text = text.Replace(&quot;&amp;colon;&quot;, &quot;:&quot;);
                text = HttpUtility.HtmlDecode(text);
            }
            return text;
        }

        public static DataSet ToDataSet&lt;T&gt;(this IList&lt;T&gt; list)
        {
            Type elementType = typeof(T);
            DataSet ds = new DataSet();
            DataTable t = new DataTable();
            ds.Tables.Add(t);

            //add a column to table for each public property on T
            foreach (var propInfo in elementType.GetProperties())
            {
                Type ColType = Nullable.GetUnderlyingType(propInfo.PropertyType) ?? propInfo.PropertyType;

                t.Columns.Add(propInfo.Name, ColType);
            }

            //go through each property on T and add each value to the table
            if (list != null)
            {
                foreach (T item in list)
                {
                    DataRow row = t.NewRow();

                    foreach (var propInfo in elementType.GetProperties())
                    {
                        row[propInfo.Name] = propInfo.GetValue(item, null) ?? DBNull.Value;
                    }

                    t.Rows.Add(row);
                }
            }

            return ds;
        }

    }


    public static class LinqHelper
    {
        #region Delegates

        public delegate object[] CreateRowDelegate&lt;T&gt;(T t);

        #endregion

        public static DataTable ToDataTable&lt;T&gt;(this IEnumerable&lt;T&gt; varlist, CreateRowDelegate&lt;T&gt; fn)
        {
            int count = 0;
            try
            {
                count = varlist.Count();
            }
            catch (Exception ex)
            {
                throw new Exception(
                    &quot;The supplied IEnumerable object is empty and can not be converted to a DataTable; Error : \&quot;&quot; +
                    ex.Message + &quot;\&quot;&quot;, ex);
            }

            var dtReturn = new DataTable();
            if (count &gt; 0)
            {
                T TopDTO = varlist.ElementAt(0);
                if (TopDTO != null)
                {
                    PropertyInfo[] dTOProps = TopDTO.GetType().GetProperties();
                    foreach (PropertyInfo pi in dTOProps)
                    {
                        Type colType = pi.PropertyType;
                        if ((colType.IsGenericType) &amp;&amp; (colType.GetGenericTypeDefinition() == typeof(Nullable&lt;&gt;)))
                            colType = colType.GetGenericArguments()[0];
                        dtReturn.Columns.Add(new DataColumn(pi.Name, colType));
                    }

                    foreach (T dTO in varlist)
                    {
                        DataRow dr = dtReturn.NewRow();
                        foreach (PropertyInfo pi in dTOProps)
                            dr[pi.Name] = pi.GetValue(dTO, null) == null ? DBNull.Value : pi.GetValue(dTO, null);
                        dtReturn.Rows.Add(dr);
                    }
                }
            }
            return dtReturn;
        }

        public static void CopyTo&lt;T&gt;(this T src, T trg)
        {
            PropertyInfo[] srcProps = (src.GetType()).GetProperties();
            PropertyInfo[] trgProps = (trg.GetType()).GetProperties();
            foreach (PropertyInfo srcPI in srcProps)
                foreach (PropertyInfo trgPI in trgProps)
                    if (srcPI.Name.Equals(trgPI.Name))
                        trgPI.SetValue(trg, srcPI.GetValue(src, null), null);
        }

        public static void ForEach&lt;T&gt;(this IEnumerable&lt;T&gt; source, Action&lt;T&gt; action)
        {
            foreach (T item in source)

                action(item);
        }


        public static T Find&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; func) where T : class
        {
            foreach (T item in source)
            {
                if (func(item))
                    return item;
            }
            return null;
        }

        public static ICollection&lt;T&gt; FindAll&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; func) where T : class
        {
            ICollection&lt;T&gt; toReturn = new List&lt;T&gt;();

            foreach (T item in source)
            {
                if (func(item))
                    toReturn.Add(item);
            }
            return toReturn;
        }

        public static void FillDTO(this DataRow dataRow, object obj)
        {
            try
            {
                // var returnObject = Activator.CreateInstance(type);
                Type type = obj.GetType();
                if (obj == null) obj = Activator.CreateInstance(type);
                foreach (var property in type.GetProperties())
                {
                    foreach (DataColumn key in dataRow.Table.Columns)
                    {
                        string columnName = key.ColumnName;
                        if (!String.IsNullOrEmpty(dataRow[columnName].ToString()))
                        {
                            if (property.Name == columnName)
                            {
                                Type t = Nullable.GetUnderlyingType(property.PropertyType) ?? property.PropertyType;
                                object safeValue;
                                if (!t.IsEnum)
                                    safeValue = (dataRow[columnName] == null)
                                        ? null
                                        : Convert.ChangeType(dataRow[columnName], t);
                                else
                                    safeValue = (dataRow[columnName] == null)
                                        ? null
                                        : Enum.Parse(t, dataRow[columnName].ToString(), true);

                                property.SetValue(obj, safeValue, null);
                            }
                        }
                    }
                }
            }
            catch (MissingMethodException)
            {
            }
        }

        public static string DataTableToJSON(this DataTable table)
        {
            var list = new List&lt;Dictionary&lt;string, object&gt;&gt;();

            foreach (DataRow row in table.Rows)
            {
                var dict = new Dictionary&lt;string, object&gt;();

                foreach (DataColumn col in table.Columns)
                {
                    dict[col.ColumnName] = row[col];
                }
                list.Add(dict);
            }
            JavaScriptSerializer serializer = new JavaScriptSerializer();
            return serializer.Serialize(list);
        }
        public static bool IsValidEmail(this string email)
        {
            try
            {
                var addr = new System.Net.Mail.MailAddress(email);
                return true;
            }
            catch
            {
                return false;
            }
        }

    }

    public static class XmlNodeHelper
    {
        public static void CopyTo&lt;T&gt;(this XmlNode xNode, T target)
        {
            PropertyInfo[] trgProps = (target.GetType()).GetProperties();

            foreach (PropertyInfo trgPI in trgProps)
            {
                string data = xNode.Attributes[trgPI.Name.ToLower2()].InnerText;

                trgPI.SetValue(target, data, null);
            }
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[26,9,26,10,1],[27,13,27,43,1],[28,9,28,10,1],[31,9,31,10,1],[32,13,32,43,1],[33,9,33,10,1],[36,9,36,10,0],[37,13,37,109,0],[38,9,38,10,0],[41,9,41,10,1],[42,13,42,71,1],[43,9,43,10,1],[46,9,46,10,1],[47,13,47,71,1],[48,9,48,10,1],[51,9,51,10,1],[52,13,52,71,1],[53,9,53,10,1],[56,9,56,10,1],[57,13,57,75,1],[58,9,58,10,1],[61,9,61,10,1],[62,13,62,73,1],[63,9,63,10,1],[66,9,66,10,1],[67,13,67,73,1],[68,9,68,10,1],[71,9,71,10,1],[72,13,72,72,1],[73,9,73,10,1],[76,9,76,10,0],[77,13,77,72,0],[78,9,78,10,0],[81,9,81,10,1],[82,13,82,72,1],[83,9,83,10,1],[86,9,86,10,1],[87,13,87,65,1],[88,9,88,10,1],[91,9,91,10,0],[93,13,93,14,0],[94,17,94,47,0],[95,21,95,54,0],[97,21,97,45,0],[99,13,99,18,0],[100,13,100,14,0],[101,17,101,50,0],[103,9,103,10,0],[106,9,106,10,1],[107,13,107,44,1],[108,13,108,14,1],[109,17,109,38,1],[110,17,110,53,1],[111,21,111,33,1],[113,17,113,53,1],[114,21,114,34,1],[115,13,115,14,0],[116,13,116,73,0],[117,9,117,10,1],[120,9,120,10,1],[121,13,121,73,1],[122,9,122,10,1],[125,9,125,10,0],[126,13,126,69,0],[127,17,127,50,0],[129,13,129,73,0],[130,9,130,10,0],[133,9,133,10,1],[134,13,134,72,1],[135,9,135,10,1],[138,9,138,10,1],[139,13,139,88,1],[140,9,140,10,1],[158,9,158,10,1],[159,13,159,68,1],[160,9,160,10,1],[163,9,163,10,1],[164,13,164,68,1],[165,9,165,10,1],[168,9,168,10,1],[169,13,169,68,1],[170,9,170,10,1],[173,9,173,10,0],[174,13,174,68,0],[175,9,175,10,0],[186,9,186,10,0],[187,13,187,54,0],[188,13,188,67,0],[189,13,189,14,0],[190,17,190,33,0],[192,17,192,38,0],[193,17,193,18,0],[194,21,194,58,0],[195,21,195,39,0],[196,21,196,22,0],[197,25,197,38,0],[197,39,197,71,0],[199,25,199,54,0],[199,55,199,65,0],[200,25,200,84,0],[201,25,201,37,0],[201,38,201,76,0],[203,25,203,83,0],[205,25,205,88,0],[206,21,206,22,0],[207,17,207,18,0],[208,13,208,14,0],[209,13,209,27,0],[210,9,210,10,0],[213,9,213,10,1],[214,13,214,71,1],[215,9,215,10,1],[218,9,218,10,1],[219,13,219,73,1],[220,9,220,10,1],[223,9,223,10,1],[224,13,224,72,1],[225,9,225,10,1],[229,9,229,10,1],[230,13,230,47,1],[231,13,231,51,1],[232,13,232,36,1],[234,13,234,75,1],[235,17,235,35,1],[237,13,237,78,1],[238,13,238,14,1],[240,17,241,120,1],[242,17,242,18,1],[243,21,243,86,1],[244,21,244,90,1],[245,17,245,18,1],[246,22,246,81,1],[247,17,247,18,1],[248,21,248,47,1],[249,21,249,121,1],[250,21,251,57,1],[252,21,252,41,1],[253,17,253,18,1],[255,17,255,18,0],[257,21,257,48,0],[258,25,258,67,0],[260,25,260,31,0],[262,13,262,14,1],[263,13,263,38,1],[264,9,264,10,1],[268,9,268,10,0],[269,13,271,36,0],[271,36,271,65,0],[271,65,271,72,0],[271,72,271,101,0],[271,101,271,103,0],[269,13,271,103,0],[272,9,272,10,0],[275,9,275,10,1],[276,13,276,46,1],[277,13,277,72,1],[278,13,278,59,1],[279,13,279,44,1],[280,13,280,34,1],[281,13,281,51,1],[282,13,282,38,1],[283,9,283,10,1],[286,9,286,10,0],[287,13,287,29,0],[288,17,288,30,0],[290,13,295,15,0],[296,13,296,56,0],[297,9,297,10,0],[300,9,300,10,1],[301,13,301,66,1],[302,17,302,41,0],[304,13,304,14,1],[305,17,305,36,1],[306,21,306,50,0],[306,50,306,59,0],[306,59,306,61,0],[306,21,306,61,0],[308,21,308,28,1],[308,30,308,35,1],[308,36,308,38,1],[308,39,308,51,1],[309,21,309,22,1],[310,25,310,63,1],[311,29,311,41,1],[312,21,312,22,1],[313,13,313,14,1],[315,13,315,26,1],[316,9,316,10,1],[319,9,319,10,1],[320,13,320,66,1],[321,17,321,41,0],[323,13,323,14,1],[324,17,324,36,1],[325,21,325,50,0],[325,50,325,59,0],[325,59,325,61,0],[325,21,325,61,0],[327,21,327,28,1],[327,30,327,40,1],[327,41,327,43,1],[327,44,327,56,1],[328,21,328,22,1],[329,25,329,79,1],[330,29,330,41,1],[331,21,331,22,1],[332,13,332,14,1],[334,13,334,26,1],[335,9,335,10,1],[337,60,337,61,0],[337,62,337,109,0],[337,110,337,111,0],[339,59,339,60,0],[339,61,339,108,0],[339,109,339,110,0],[341,60,341,61,0],[341,62,341,109,0],[341,110,341,111,0],[343,61,343,62,0],[343,63,343,110,0],[343,111,343,112,0],[345,62,345,63,0],[345,64,345,111,0],[345,112,345,113,0],[347,63,347,64,0],[347,65,347,112,0],[347,113,347,114,0],[349,91,349,92,1],[349,93,349,134,1],[349,135,349,136,1],[351,92,351,93,1],[351,94,351,130,1],[351,131,351,132,1],[361,9,361,10,0],[362,13,362,66,0],[363,17,363,41,0],[365,13,365,14,0],[366,17,366,36,0],[367,21,367,50,0],[367,50,367,59,0],[367,59,367,61,0],[367,21,367,61,0],[369,21,369,28,0],[369,30,369,40,0],[369,41,369,43,0],[369,44,369,56,0],[370,21,370,22,0],[371,25,371,65,0],[372,29,372,41,0],[373,21,373,22,0],[374,13,374,14,0],[376,13,376,26,0],[377,9,377,10,0],[387,9,387,10,1],[388,13,388,44,1],[390,13,390,74,1],[391,17,391,43,0],[393,13,393,20,1],[393,22,393,27,1],[393,28,393,30,1],[393,31,393,47,1],[394,13,394,14,1],[395,17,395,50,1],[396,17,396,18,0],[397,21,397,48,0],[398,21,398,27,0],[400,13,400,14,1],[402,13,402,39,1],[403,9,403,10,1],[413,9,413,10,0],[414,13,414,45,0],[416,13,416,74,0],[417,17,417,29,0],[419,13,419,20,0],[419,22,419,27,0],[419,28,419,30,0],[419,31,419,47,0],[420,13,420,14,0],[421,17,421,49,0],[422,17,422,18,0],[423,21,423,47,0],[424,21,424,27,0],[426,13,426,14,0],[428,13,428,39,0],[429,9,429,10,0],[438,9,438,10,1],[439,13,439,41,1],[440,17,440,29,1],[442,13,442,70,0],[443,13,443,28,0],[444,9,444,10,1],[447,9,447,10,0],[448,13,448,48,0],[449,17,449,33,0],[451,13,451,133,0],[452,13,452,90,0],[454,13,454,95,0],[455,9,455,10,0],[464,9,464,10,0],[465,13,465,60,0],[466,9,466,10,0],[475,9,475,10,1],[476,13,476,64,1],[477,9,477,10,1],[485,9,485,10,1],[486,13,486,64,1],[487,9,487,10,1],[495,9,495,10,0],[496,13,496,55,0],[497,9,497,10,0],[506,9,506,10,0],[507,13,507,37,0],[508,17,508,37,0],[510,13,510,81,0],[511,9,511,10,0],[520,9,520,10,1],[521,13,521,37,1],[522,17,522,37,0],[524,13,524,76,1],[525,9,525,10,1],[528,9,528,10,1],[529,13,529,55,1],[530,13,530,14,1],[531,17,531,52,1],[532,17,532,30,1],[537,13,537,132,1],[539,13,539,67,1],[540,13,540,14,1],[541,17,541,68,1],[542,17,542,29,1],[545,13,545,48,1],[546,13,546,26,1],[547,9,547,10,1],[550,9,550,10,1],[551,13,551,35,1],[553,13,553,55,1],[554,17,554,29,1],[556,13,556,75,1],[558,13,558,51,1],[559,17,559,29,1],[561,13,561,60,1],[562,13,562,14,1],[563,17,563,84,1],[565,17,565,44,1],[566,21,566,52,1],[568,17,568,29,1],[570,18,570,64,1],[571,13,571,14,0],[572,17,572,74,0],[573,17,573,29,0],[576,40,576,63,1],[578,13,578,37,1],[579,13,579,14,1],[580,17,580,116,1],[581,17,581,31,1],[582,17,582,18,1],[583,21,583,55,1],[584,21,584,38,1],[587,13,587,14,1],[589,13,589,78,1],[591,13,591,47,1],[593,13,593,30,1],[594,9,594,10,1],[597,9,597,10,1],[598,13,598,35,1],[600,13,600,108,1],[601,13,601,14,1],[602,17,602,41,1],[603,21,603,78,1],[605,21,605,67,0],[606,17,606,29,1],[609,13,609,26,1],[610,9,610,10,1],[613,9,613,10,1],[614,13,614,35,1],[616,13,616,108,1],[617,13,617,14,1],[618,17,618,49,1],[619,21,619,43,1],[621,17,621,18,1],[622,21,622,45,1],[623,25,623,88,1],[625,25,625,77,0],[626,17,626,18,1],[627,17,627,29,1],[630,13,630,26,0],[631,9,631,10,1],[643,9,643,10,0],[644,13,644,113,0],[645,9,645,10,0],[648,9,648,10,0],[649,13,649,43,0],[650,17,650,35,0],[652,13,652,69,0],[653,9,653,10,0],[656,9,656,10,0],[657,13,657,28,0],[658,13,658,20,0],[658,22,658,30,0],[658,31,658,33,0],[658,34,658,49,0],[659,13,659,14,0],[660,17,660,25,0],[661,17,661,35,0],[662,21,662,34,0],[663,13,663,14,0],[665,13,665,23,0],[666,9,666,10,0],[668,9,668,10,1],[669,13,669,50,1],[670,13,670,14,1],[671,17,671,53,1],[672,17,672,53,1],[673,13,673,14,1],[674,13,674,25,1],[675,9,675,10,1],[677,9,677,10,1],[678,13,678,50,1],[679,13,679,14,1],[680,17,680,53,1],[681,17,681,53,1],[682,13,682,14,1],[683,13,683,25,1],[684,9,684,10,1],[687,9,687,10,0],[688,13,688,42,0],[689,13,689,40,0],[690,13,690,43,0],[691,13,691,30,0],[694,13,694,20,0],[694,22,694,34,0],[694,35,694,37,0],[694,38,694,65,0],[695,13,695,14,0],[696,17,696,107,0],[698,17,698,55,0],[699,13,699,14,0],[702,13,702,30,0],[703,13,703,14,0],[704,17,704,24,0],[704,26,704,32,0],[704,33,704,35,0],[704,36,704,40,0],[705,17,705,18,0],[706,21,706,46,0],[708,21,708,28,0],[708,30,708,42,0],[708,43,708,45,0],[708,46,708,73,0],[709,21,709,22,0],[710,25,710,92,0],[711,21,711,22,0],[713,21,713,37,0],[714,17,714,18,0],[715,13,715,14,0],[717,13,717,23,0],[718,9,718,10,0],[732,9,732,10,1],[733,13,733,27,1],[735,13,735,14,1],[736,17,736,41,1],[737,13,737,14,1],[738,13,738,33,0],[739,13,739,14,0],[740,17,742,44,0],[745,13,745,44,1],[746,13,746,27,1],[747,13,747,14,1],[748,17,748,49,1],[749,17,749,36,1],[750,17,750,18,1],[751,21,751,80,1],[752,21,752,28,1],[752,30,752,45,1],[752,46,752,48,1],[752,49,752,57,1],[753,21,753,22,1],[754,25,754,56,1],[755,25,755,115,1],[756,29,756,72,0],[757,25,757,80,1],[758,21,758,22,1],[760,21,760,28,1],[760,30,760,35,1],[760,36,760,38,1],[760,39,760,46,1],[761,21,761,22,1],[762,25,762,56,1],[763,25,763,32,1],[763,34,763,49,1],[763,50,763,52,1],[763,53,763,61,1],[764,29,764,114,1],[765,25,765,47,1],[766,21,766,22,1],[767,17,767,18,1],[768,13,768,14,1],[769,13,769,29,1],[770,9,770,10,1],[773,9,773,10,1],[774,13,774,71,1],[775,13,775,71,1],[776,13,776,20,1],[776,22,776,40,1],[776,41,776,43,1],[776,44,776,52,1],[777,17,777,24,1],[777,26,777,44,1],[777,45,777,47,1],[777,48,777,56,1],[778,21,778,55,1],[779,25,779,78,1],[780,9,780,10,1],[783,9,783,10,1],[784,13,784,20,1],[784,22,784,28,1],[784,29,784,31,1],[784,32,784,38,1],[786,17,786,30,1],[787,9,787,10,1],[791,9,791,10,1],[792,13,792,20,1],[792,22,792,28,1],[792,29,792,31,1],[792,32,792,38,1],[793,13,793,14,1],[794,17,794,32,1],[795,21,795,33,1],[796,13,796,14,1],[797,13,797,25,1],[798,9,798,10,1],[801,9,801,10,0],[802,13,802,53,0],[804,13,804,20,0],[804,22,804,28,0],[804,29,804,31,0],[804,32,804,38,0],[805,13,805,14,0],[806,17,806,32,0],[807,21,807,40,0],[808,13,808,14,0],[809,13,809,29,0],[810,9,810,10,0],[813,9,813,10,1],[815,13,815,14,1],[817,17,817,43,1],[818,17,818,33,1],[818,34,818,71,0],[819,17,819,24,1],[819,26,819,38,1],[819,39,819,41,1],[819,42,819,62,1],[820,17,820,18,1],[821,21,821,28,1],[821,30,821,44,1],[821,45,821,47,1],[821,48,821,69,1],[822,21,822,22,1],[823,25,823,60,1],[824,25,824,83,1],[825,25,825,26,1],[826,29,826,61,1],[827,29,827,30,1],[828,33,828,117,1],[830,33,830,47,1],[831,37,833,86,1],[835,37,837,95,0],[839,33,839,73,1],[840,29,840,30,1],[841,25,841,26,1],[842,21,842,22,1],[843,17,843,18,1],[844,13,844,14,1],[845,13,845,43,0],[846,13,846,14,0],[847,13,847,14,0],[848,9,848,10,1],[851,9,851,10,1],[852,13,852,63,1],[854,13,854,20,1],[854,22,854,33,0],[854,34,854,36,1],[854,37,854,47,1],[855,13,855,14,0],[856,17,856,61,0],[858,17,858,24,0],[858,26,858,40,0],[858,41,858,43,0],[858,44,858,57,0],[859,17,859,18,0],[860,21,860,53,0],[861,17,861,18,0],[862,17,862,32,0],[863,13,863,14,0],[864,13,864,74,1],[865,13,865,47,1],[866,9,866,10,1],[868,9,868,10,1],[870,13,870,14,1],[871,17,871,67,1],[872,17,872,29,1],[874,13,874,18,1],[875,13,875,14,1],[876,17,876,30,1],[878,9,878,10,1],[885,9,885,10,0],[886,13,886,74,0],[888,13,888,20,0],[888,22,888,40,0],[888,41,888,43,0],[888,44,888,52,0],[889,13,889,14,0],[890,17,890,81,0],[892,17,892,52,0],[893,13,893,14,0],[894,9,894,10,0]]);
    </script>
  </body>
</html>